import streamlit as st
import traceback

# importing experts
import os, sys
geode_dir = os.path.abspath(os.curdir)
if geode_dir not in sys.path:
    sys.path.append(geode_dir)

from experts.functional_experts import *
from experts.model_experts import *  
from experts.database_experts import *  
from style import *


st.set_page_config(page_title="Geode", layout="wide", page_icon="ðŸª¨")

# setting up session states
if 'generated_code' not in st.session_state:
    st.session_state['generated_code'] = [{'content': '# No code generated yet'}]
if 'messages' not in st.session_state:
    st.session_state['messages'] = [{'role': 'assistant', 'content': 'Ask me anything geospatial!'}]
st.session_state.latest_query = ''
st.session_state.code_ok = None
st.session_state.latest_patch = None
st.session_state.error_text = None
# st.session_state.code_model = 'gpt-3.5-turbo' 
st.session_state.code_model = 'claude-3-opus'

# global styling
st.markdown(global_style_string, unsafe_allow_html=True)

def cleanup_code(code: str) -> str:
    '''
    Cleanup
    '''
    if code is None:
        return None
    def_index = code.find('def')
    # If 'def' is found, return the substring starting from that index
    if def_index != -1:
        return code[def_index:]
    # If 'def' is not found, return the original string
    else:
        return code  


def execute_code(code: str):
    '''
    Function to execute code generated by the codegen model.
    '''
    # namespace = globals()
    # exec(code, namespace) # TODO figure out observer injection
    # answer, patch = namespace['result'][0], namespace['result'][1]
    # return answer, patch

    answer, patch = None, None
    try:
        namespace = globals()
        exec(code, namespace)
        answer, patch = namespace['result'][0], namespace['result'][1]
        st.session_state.error_text = None
        
        # safeguards
        # vector_keys = ['location', 'bbox', 'points', 'boundary']
        # raster_keys = ['name', 'type', 'colormap', 'data']
        # for key in vector_keys:
        #     if key not in patch.vector_data:
        #         patch.vector_data[key] = None
        # for key in raster_keys:
        #     if key not in patch.raster_data:
        #         patch.raster_data[key] = None

        return answer, patch
    except Exception:
        error_text = traceback.format_exc()
        st.session_state.error_text = error_text

        if answer is not None and patch is None:
            return answer, None
        elif answer is None and patch is not None:
            return 'I do not have a textual answer for your query, please check the map output instead!', patch
        elif answer is None and patch is None:
            return 'The code I generated did not run well. You can ask your question again. If problem persists, I probably cannot solve your query, given my current capabilities.', None

def reset_chat():
    '''
    Function to clear chat history and start a new conversation
    '''
    for key in st.session_state.keys():
        del st.session_state[key]

    # reset session with code gen model
        # todo


def main():
    '''
    Main layout for the Geode app
    '''
    left_col, right_col = st.columns([3, 2])

    with left_col:
        st.markdown("### __Geode__")
            
        # conversation area
        conversation = st.container(height=520)
        for answer in st.session_state.messages:
            conversation.chat_message(answer["role"], avatar='ðŸª¨' if answer['role'] == 'assistant' else 'ðŸ§‘').write(answer["content"])

        # input area
        button_col, input_col = st.columns([1, 2])
        button_col.button('New chat', on_click=reset_chat)
        query = input_col.chat_input(key="input", placeholder='Enter your prompt')

        if query:
            # reading the user prompt
            st.session_state.messages.append({"role": "user", "content": query})
            st.session_state.latest_query = query
            conversation.chat_message("user", avatar='ðŸ§‘').write(query)

            # generating code to solve the query
            # code = code_gen_expert(base_prompt + prompt)
            code = code_gen_expert(query, model=st.session_state.code_model)
            code = cleanup_code(code)
            answer, patch = execute_code(code)
            print(patch)
            st.session_state.latest_patch = patch
            
            # displaying the answer and generated code, saving it
            st.session_state.generated_code.append({'content': code}) # put generated code here
            st.session_state.messages.append({"role": "assistant", "content": answer}) # put generated answer here
            conversation.chat_message("assistant", avatar='ðŸª¨').write(answer)

    with right_col:
        # map output
        st.markdown('<div style="padding-top:18px;padding-bottom:15px;">Map output</div>', unsafe_allow_html=True)
        
        # tests
        # patch_visualization_expert(patch=patch_location_expert(st.session_state.latest_query))
        # patch_visualization_expert(patch=point_location_expert(st.session_state.latest_query))
        # patch_visualization_expert(patch=precipitation_expert(point_location_expert(st.session_state.latest_query)))
        # patch_visualization_expert(
        #     patch=threshold_expert(
        #         precipitation_expert(
        #             point_location_expert(
        #                 st.session_state.latest_query
        #             )
        #         ),
        #         threshold=0.6
        #     )
        # )
        # patch_visualization_expert(patch=air_quality_expert(patch_location_expert(st.session_state.latest_query), parameter='us-epa-index'))
        # patch_visualization_expert(patch=threshold_expert(air_quality_expert(patch_location_expert(st.session_state.latest_query)), threshold=0.5, mode='greater'))
        # patch_visualization_expert(patch=air_quality_expert(point_location_expert(st.session_state.latest_query), mode='point')[1])
        # patch_visualization_expert(patch=precipitation_expert(patch_location_expert(st.session_state.latest_query)))
        # patch_visualization_expert(patch=humidity_expert(patch_location_expert(st.session_state.latest_query))) # todo inferring the mode automatically
        # patch_visualization_expert(patch=elevation_expert(patch_location_expert(st.session_state.latest_query))) # todo inferring the mode automatically
        # 
        # patch = patch_location_expert(st.session_state.latest_query)
        # patch_visualization_expert(
        #     patch=intersection_expert(
        #         patch1=threshold_expert(humidity_expert(patch), 0.4),
        #         patch2=threshold_expert(precipitation_expert(patch), 0.1),
        #         mode='raster'
        #     )
        # )
        # patch_visualization_expert(patch=temperature_expert(patch_location_expert(st.session_state.latest_query))) # todo inferring the mode automatically

        patch_visualization_expert(patch=st.session_state.latest_patch)

        # generated code
        st.markdown("Generated code")
        
        # if st.session_state.code_ok is not None and not st.session_state.code_ok:
        #     st.toast('Failed to run generated code.')
        #     st.button(label='Regenerate')
            
        st.markdown(
            f"""```python
            {st.session_state.generated_code[-1]['content']}
            """
        )
    
    if st.session_state.error_text is not None:
        st.error(body=st.session_state.error_text)


if __name__ == "__main__":
    main()
